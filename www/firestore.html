
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<body>
  <!-- Include Firebase SDK -->
  <!-- Include other Firebase SDKs as needed -->
  <style>
    .loader-profile {
  border: 16px solid #f3f3f3; /* Light grey */
  border-top: 16px solid #3498db; /* Blue */
  margin-left: 300px;
  margin-top: 200px;
  border-radius: 50%;
  width: 120px;
  height: 120px;
  animation: spin 2s linear infinite;
}
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
  </style>
  <script src="https://www.gstatic.com/firebasejs/10.6.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.6.0/firebase-firestore-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  
  <script>
    function getRandomColor(index) {
      const colors = ["red", "blue", "green", "orange", "purple", "brown", "olive", "black"];
      return colors[index % colors.length];
    };

    function getBorderDash(index) {
      if (index < 8) {
        return undefined;
      } else {
        return [2*Math.floor(index / 8), 2*Math.floor(index / 8)];
      }
    }

    function createChart(category, data, isLoudspeaker) {
      // Create a canvas element

      const plotCanvas = document.createElement("canvas");


      let minY = Math.min(
        ...data.map((dataset) =>
          Math.min(
            ...dataset.data
            .filter((point) => !isNaN(point.y))
            .map((point) => point.y)
          )
        )
      );
      
      minY = Math.floor(minY / 10) * 10;
      console.log(minY);

      let maxY = Math.max(
        ...data.map((dataset) =>
          Math.max(
            ...dataset.data
            .filter((point) => !isNaN(point.y))
            .map((point) => point.y)
          )
        )
      );
      maxY = Math.ceil(maxY / 10) * 10;
      console.log(maxY);
      // Create the chart
      plotCanvas.width = 1000;
      plotCanvas.height = (maxY - minY) * 11 + Math.ceil(data.length/3)*10;

      var chart = new Chart(plotCanvas, {
        type: "line",
        data: {
          datasets: data
        },
        options: {
          responsive: false,
          maintainAspectRatio: true,
          scales: {
            x: {
              type: "logarithmic",
              position: "bottom",
              title: {
                display: true,
                text: "Frequency (Hz)",
                font: {
                  size: "19px",
                },
              },
              min: 20,
              max: 20000,
              ticks: {
                callback: function (value, index, values) {
                  const tickValues = [
                    20, 100, 200, 1000, 2000, 10000, 16000, 20000,
                  ];
                  return tickValues.includes(value) ? value : "";
                },
                font: {
                  size: 15,
                },
              },
            },
            y: {
              type: "linear",
              position: "left",
              title: {
                display: true,
                text: "Gain (dB)",
                font: {
                  size: "19px",
                },
              },
              min: minY,
              max: maxY,
              ticks: {
                stepSize: 10,
                font: {
                  size: 15,
                },
              },
            },
          },
          plugins: {
            legend: {
              labels: {
                font: {
                  size: 15,
                },
                usePointStyle: true,
                pointStyle: "line",
                generateLabels: function (chart) {
                  const data = chart.data;

                  if (data.datasets.length) {
                    // Number of columns you want

                    return data.datasets.map(function (dataset, i) {
                      return {
                        text: dataset.label,
                        fillStyle: dataset.backgroundColor,
                        strokeStyle: dataset.borderColor,
                        lineWidth: dataset.borderWidth,
                        hidden: !chart.isDatasetVisible(i),
                        index: i,
                        lineDash: dataset.borderDash,
                        pointStyle: "line",
                      };
                    });
                  }

                  return [];
                },
              },
            },
            title: {
              display: true,
              text: "Profiles for " + category,
              font: {
                size: 22,
                weight: "normal",
                family: "system-ui",
              },
            },
          },
        },
      });
      document.getElementById("microphonePlots").appendChild(plotCanvas);
    };


  </script>
  
  <script type="module">
    document.getElementById("microphonePlots").innerHTML = "<div class='loader-profile'></div>";
    const firebaseConfig = {
      apiKey: "AIzaSyDZopCl6jqND4sFYCSiB1GpCXreXd6-Q9s",
      authDomain: "speaker-calibration.firebaseapp.com",
      databaseURL: "https://speaker-calibration-default-rtdb.firebaseio.com",
      projectId: "speaker-calibration",
      storageBucket: "speaker-calibration.appspot.com",
      messagingSenderId: "322038930574",
      appId: "1:322038930574:web:d10ca9e7d60b6da9bafddf",
      measurementId: "G-3724GD92R6",
    };
    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    function addToMap(map, value) {
      const lowercaseValue = value.toLowerCase();
      if (!map.has(lowercaseValue)) {
        map.set(lowercaseValue, []);
      }
      map.get(lowercaseValue).push(value);
    }

    var micOEMs = new Set();
    var micModelNames = new Set();
    var micIDs = new Set();

    var micOEMsMap = new Map();
    var micModelNamesMap = new Map();
    var micIDsMap = new Map();
    
    var mics = db.collection("Microphones");
    var loudspeakers = db.collection("Loudspeakers");
    await mics.get().then((querySnapshot) => {
      querySnapshot.forEach((doc) => {
        addToMap(micOEMsMap, doc.data().OEM);
        addToMap(micModelNamesMap, doc.data().micModelName);
        addToMap(micIDsMap, doc.data().ID);
      });
    });
    micOEMsMap.forEach((values, lowercaseOEM) => {
      const firstCaseOEM = values[0];
      if (firstCaseOEM) {
        micOEMs.add(firstCaseOEM );
      }
    });
    micModelNamesMap.forEach((values, micModelName) => {
      const firstCaseMicModelName = values[0];
      if (firstCaseMicModelName) {
        micModelNames.add(firstCaseMicModelName);
      }
    });
    micIDsMap.forEach((values, lowercaseID) => {
      const firstCaseID = values[0];
      if (firstCaseID) {
        micIDs.add(firstCaseID);
      }
    });


    var speakerOEMs = new Set();
    var speakerModelNames = new Set();
    var speakerIDs = new Set();

    var speakerOEMsMap = new Map();
    var speakerModelNamesMap = new Map();
    var speakerIDsMap = new Map();

    await loudspeakers
    .get()
    .then((querySnapshot) => {
      querySnapshot.forEach((doc) => {
        addToMap(speakerOEMsMap, doc.data().OEM);
        addToMap(speakerModelNamesMap, doc.data().fullLoudspeakerModelName);
        addToMap(speakerIDsMap, doc.data().fullLoudspeakerModelNumber);
        })
      });
    
      speakerOEMsMap.forEach((values, lowercaseOEM) => {
        const firstCaseOEM = values[0];
        if (firstCaseOEM) {
          speakerOEMs.add(firstCaseOEM);
          console.log(firstCaseOEM);
        }
      });
      speakerModelNamesMap.forEach((values, speakerModelName) => {
        const firstCaseMicModelName = values[0];
        if (firstCaseMicModelName) {
          speakerModelNames.add(firstCaseMicModelName);
          console.log(firstCaseMicModelName);
        }
      });
      speakerIDsMap.forEach((values, lowercaseID) => {
        const firstCaseID = values[0];
        if (firstCaseID) {
          speakerIDs.add(firstCaseID);
          console.log(firstCaseID);
        }
      });

    // Shiny.setInputValue("OEMs", OEMs);
    // Shiny.setInputValue("MicModelNames",MicModelNames);
    // Shiny.setInputValue("IDs", IDs);

    const SDToleranceContainer = document.getElementById("SDTolerance");
    const filterBoolContainer = document.getElementById("filterBool");
    filterBoolContainer.checked = false;
    SDToleranceContainer.value = 10.0;
    const transducerSelect = document.getElementById("transducer");
    transducerSelect.innerHTML = "";
    let microphoneOption = document.createElement("option");
    microphoneOption.value = "Microphones";
    microphoneOption.text = "Microphones";
    transducerSelect.add(microphoneOption);
    let loudspeakerOption = document.createElement("option");
    loudspeakerOption.value = "Loudspeakers";
    loudspeakerOption.text = "Loudspeakers";
    transducerSelect.add(loudspeakerOption);

    const OEMSelect = document.getElementById("OEM");
    const modelsContainer = document.getElementById("Model");
    const IDcontainers = document.getElementById("IDs");
    
    function updateOEMsContainer() {
      OEMSelect.innerHTML = "";
      let OEMelement = document.createElement("option");
      OEMelement.value = "All";
      OEMelement.text = "All";
      OEMSelect.add(OEMelement);
     
      if (transducerSelect.value == "Microphones") {
        micOEMs.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        OEMSelect.add(optionElement);
      });
      } else {
        speakerOEMs.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        OEMSelect.add(optionElement);
      });
      }
    }

    function updateModelsContainer() {
      modelsContainer.innerHTML = "";
      let modelElement = document.createElement("option");
      modelElement.value = "All";
      modelElement.text = "All";
      modelsContainer.add(modelElement);
      if (transducerSelect.value == "Microphones") {
        micModelNames.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        modelsContainer.add(optionElement);
      });
      } else {
        speakerModelNames.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        modelsContainer.add(optionElement);
      });
      }
      
    }
    
    function updateIDContainer() {
      IDcontainers.innerHTML = "";
      let IDElement = document.createElement("option");
      IDElement.value = "All";
      IDElement.text = "All";
      IDcontainers.add(IDElement);
      if (transducerSelect.value == "Microphones") {
        micIDs.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        IDcontainers.add(optionElement);
      });
      } else {
        speakerIDs.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        IDcontainers.add(optionElement);
      });
      }
    }
    
    updateOEMsContainer();
    updateModelsContainer();
    updateIDContainer();

    async function updatePlot(whatToPlot) {
      // const selectedModels = Array.from(modelsContainer.querySelectorAll('input[type="checkbox"]:checked')).map((checkbox) => checkbox.value);

      document.getElementById("microphonePlots").innerHTML = "<div class='loader-profile'></div>";
      const data = [];
      let i = 0;
      let query, selectedValue;
      if (whatToPlot === "micOEM") {
        // micModelNames = new Set();
        // micIDs = new Set();
        selectedValue = OEMSelect.value;
        query = selectedValue == "All" ? mics : mics.where("OEM", "in", micOEMsMap.get(selectedValue.toLowerCase()) || []);
      } else if (whatToPlot === "micModelName") {
        // micIDs = new Set();
        selectedValue = modelsContainer.value == "All" ? OEMSelect.value : modelsContainer.value;
        let ModelQuery = OEMSelect.value == "All" ? mics.where("micModelName", "in", micModelNamesMap.get(selectedValue.toLowerCase())) :
         mics.where("OEM", "in", micOEMsMap.get(OEMSelect.value.toLowerCase())).where("micModelName", "in",  micModelNamesMap.get(selectedValue.toLowerCase()));
        query = modelsContainer.value == "All" ? 
        mics.where("OEM", "==", selectedValue) :
        ModelQuery;
      } else if (whatToPlot === "micID") {
        selectedValue = IDcontainers.value == "All" ? modelsContainer.value : IDcontainers.value;
        let IDQuery = modelsContainer.value == "All" ?  mics.where("ID", "in", micIDsMap.get(selectedValue.toLowerCase())) : 
        mics.where("micModelName", "in", micModelNamesMap.get(modelsContainer.value.toLowerCase()) || [])
        .where("ID", "in", micIDsMap.get(selectedValue.toLowerCase()) || []);
        query = IDcontainers.value == "All" ? 
        mics.where("micModelName", "in", micModelNamesMap.get(selectedValue.toLowerCase()) || []) : 
        IDQuery;
      } else if (whatToPlot === "speakerOEM") {
        // speakerModelNames = new Set();
        // speakerIDs = new Set();
        selectedValue = OEMSelect.value;
        query = selectedValue == "All" ?
         loudspeakers :
          loudspeakers.where(
            "OEM",
             "in",
              speakerOEMsMap.get(selectedValue.toLowerCase()));
      } else if (whatToPlot === "speakerModelName") {
        // speakerIDs = new Set();
        selectedValue = modelsContainer.value == "All" ? OEMSelect.value : modelsContainer.value;
        let ModelQuery = OEMSelect.value == "All" ?
         loudspeakers
         .where(
          "fullLoudspeakerModelName",
           "in",
            speakerModelsMap.get(selectedValue.toLowerCase()))
          : loudspeakers
          .where(
            "OEM",
             "in",
              speakerOEMsMap.get(OEMSelect.value.toLowerCase()))
          .where(
            "fullLoudspeakerModelName",
             "in", 
             speakerModelsMap.get(selectedValue.toLowerCase()));
        query = modelsContainer.value == "All" ? 
        loudspeakersloudspeakers
          .where(
            "OEM", 
            "in", 
            speakerOEMsMap.get(OEMSelect.value.toLowerCase())) :
        ModelQuery;
      } else {
        selectedValue = IDcontainers.value == "All" ? modelsContainer.value : IDcontainers.value;
        let IDQuery = modelsContainer.value == "All" ? 
        loudspeakers
        .where("ID", "in", speakerIDsMap.get(selectedValue.toLowerCase())) :
         loudspeakers
         .where("fullLoudspeakerModelName", "in", speakerModelsMap.get(modelsContainer.value.toLowerCase()))
         .where("ID", "in", speakerIDsMap.get(selectedValue.toLowerCase()));;
        query = IDcontainers.value == "All" ? 
        loudspeakers
        .where("fullLoudspeakerModelName", "in", speakerModelsMap.get(selectedValue.toLowerCase())) : 
        IDQuery;
      }

      try {
        await query.get().then((querySnapshot) => {
          querySnapshot.forEach((doc) => {
          let docData;
          if (transducerSelect.value == "Microphones") {
            docData = doc.data().linear.Freq.map((x, i) => ({ x: x, y: doc.data().linear.Gain[i] }));
          } else {
            docData = doc.data().ir.Freq.map((x, i) => ({ x: x, y: doc.data().ir.Gain[i] }));
          }
          let label;
          
          if (whatToPlot === "micOEM") {
            // micModelNames.add(doc.data().micModelName);
            // micIDs.add(doc.data().ID);
            label = `${doc.data().micModelName}/${doc.data().isDefault ? "default" : doc.data().DateText}`;
          } else if (whatToPlot === "micModelName") {
            // micIDs.add(doc.data().ID);
            label = `${doc.data().ID}/${doc.data().isDefault ? "default" : doc.data().DateText}`;
          } else if (whatToPlot === "micID") {
            label = doc.data().isDefault ? "default" : doc.data().DateText;
            // speakers
          } else if (whatToPlot === "speakerOEM") {
            // speakerModelNames.add(doc.data().fullLoudspeakerModelName);
            // speakerIDs.add(doc.data().fullLoudspeakerModelNumber);
            label = `${doc.data().fullLoudspeakerModelName}/${doc.data().CalibrationDate}`;
          } else if (whatToPlot === "speakerModelName") {
            // speakerIDs.add(doc.data().fullLoudspeakerModelNumber);
            label = `${doc.data().fullLoudspeakerModelNumber}/${doc.data().CalibrationDate}`;
          } else if (whatToPlot === "speakerID") {
            label = doc.data().CalibrationDate;
          }

          if (
            !filterBoolContainer.checked ||
            doc.data().isDefault ||
             doc.data().componentCorrectionSD <= SDToleranceContainer.value) 
             {
            data.push({
            label: label,
            data: docData,
            backgroundColor: "rgba(0, 0, 0, 0)",
            pointRadius: 0,
            borderColor: getRandomColor(i),
            borderDash: getBorderDash(i++),
            showLine: true,
            borderWidth: 2,
          });
          }
        });

        document.getElementById("microphonePlots").innerHTML = "";
        if (whatToPlot === "micModelName") {
          updateIDContainer();
        } else if (whatToPlot === "micOEM") {
          updateModelsContainer();
          updateIDContainer();
        }
        createChart(selectedValue, data, false);

      });
      } catch (error) {
        console.error("Error updating plot:", error);
      }
    }

    transducerSelect.addEventListener("change", () => {
      if (transducerSelect.value == "Microphones") {
        updateOEMsContainer();
        updateModelsContainer();
        updateIDContainer();
        updatePlot("micOEM");
      } else {
        updateOEMsContainer();
        updateModelsContainer();
        updateIDContainer();
        updatePlot("speakerOEM");
      }
    });

    OEMSelect.addEventListener("change", async () => {
      if (transducerSelect.value == "Microphones") {
        await updatePlot("micOEM");
      } else {
        await updatePlot("speakerOEM");
      }
    });

    modelsContainer.addEventListener("change", async () => {
      if (transducerSelect.value == "Microphones") {
        await updatePlot("micModelName");
      } else {
        await updatePlot("speakerModelName");
      }
    });

    IDcontainers.addEventListener("change", async () => {
      if (transducerSelect.value == "Microphones") {
        await updatePlot("micID");
      } else {
        await updatePlot("speakerID");
      }
    });
    await updatePlot("micOEM");

    // modelsContainer.addEventListener("change", updatePlot);
    document.getElementById('refreshButton').onclick = async() => {
      if (transducerSelect.value == "Microphones") {
        if (IDcontainers.value != "All") {
          await updatePlot("micID");
        } else if (modelsContainer.value != "All") {
          await updatePlot("micModel");
        } else {
          await updatePlot("micOEM");
        }
      } else {
        if (IDcontainers.value != "All") {
          await updatePlot("speakerID");
        } else if (modelsContainer.value != "All") {
          await updatePlot("speakerModel");
        } else {
          await updatePlot("speakerOEM");
        }
      }
    }
    // updateModelCheckboxes();
    // updatePlot();

  </script>


</body>

</html>