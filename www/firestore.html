
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<body>
  <!-- Include Firebase SDK -->
  <!-- Include other Firebase SDKs as needed -->
  <style>
    .loader-profile {
  border: 16px solid #f3f3f3; /* Light grey */
  border-top: 16px solid #3498db; /* Blue */
  margin-top: 200px;
  border-radius: 50%;
  width: 120px;
  height: 120px;
  animation: spin 2s linear infinite;
}
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
  </style>
  <script src="https://www.gstatic.com/firebasejs/10.6.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.6.0/firebase-firestore-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  
  <script>
    
    function getRandomColor(index) {
      const colors = ["red", "blue", "green", "orange", "purple", "brown", "olive", "black"];
      return colors[index % colors.length];
    };

    function getBorderDash(index) {
      if (index < 8) {
        return undefined;
      } else {
        return [2*Math.floor(index / 8), 2*Math.floor(index / 8)];
      }
    }

    function createChart(category, data, isLoudspeaker) {
      // Create a canvas element

      const plotCanvas = document.createElement("canvas");


      let minY = Math.min(
        ...data.map((dataset) =>
          Math.min(
            ...dataset.data
            .filter((point) => !isNaN(point.y))
            .map((point) => point.y)
          )
        )
      );
      
      minY = Math.floor(minY / 10) * 10;
      console.log(minY);

      let maxY = Math.max(
        ...data.map((dataset) =>
          Math.max(
            ...dataset.data
            .filter((point) => !isNaN(point.y))
            .map((point) => point.y)
          )
        )
      );
      maxY = Math.ceil(maxY / 10) * 10;
      console.log(maxY);
      // Create the chart
      plotCanvas.width = 1000;
      plotCanvas.height = (maxY - minY) * 8 + Math.ceil(data.length/3)*10;

      var chart = new Chart(plotCanvas, {
        type: "line",
        data: {
          datasets: data
        },
        options: {
          responsive: false,
          maintainAspectRatio: true,
          scales: {
            x: {
              type: "logarithmic",
              position: "bottom",
              title: {
                display: true,
                text: "Frequency (Hz)",
                font: {
                  size: "19px",
                },
              },
              min: 20,
              max: 20000,
              ticks: {
                callback: function (value, index, values) {
                  const tickValues = [
                    20, 100, 200, 1000, 2000, 10000, 16000, 20000,
                  ];
                  return tickValues.includes(value) ? value : "";
                },
                font: {
                  size: 15,
                },
              },
            },
            y: {
              type: "linear",
              position: "left",
              title: {
                display: true,
                text: "Gain (dB)",
                font: {
                  size: "19px",
                },
              },
              min: minY,
              max: maxY,
              ticks: {
                stepSize: 10,
                font: {
                  size: 15,
                },
              },
            },
          },
          plugins: {
            legend: {
              labels: {
                font: {
                  size: 15,
                },
                usePointStyle: true,
                pointStyle: "line",
                generateLabels: function (chart) {
                  const data = chart.data;

                  if (data.datasets.length) {
                    // Number of columns you want

                    return data.datasets.map(function (dataset, i) {
                      return {
                        text: dataset.label,
                        fillStyle: dataset.backgroundColor,
                        strokeStyle: dataset.borderColor,
                        lineWidth: dataset.borderWidth,
                        hidden: !chart.isDatasetVisible(i),
                        index: i,
                        lineDash: dataset.borderDash,
                        pointStyle: "line",
                      };
                    });
                  }

                  return [];
                },
              },
            },
            title: {
              display: true,
              text: "Profiles for " + category,
              font: {
                size: 22,
                weight: "normal",
                family: "system-ui",
              },
            },
          },
        },
      });
      document.getElementById("profilePlot").appendChild(plotCanvas);
    };


  </script>
  
  <script type="module">
    window.alert = function(message) {
    // Do nothing or log the message to console
    console.log("Alert suppressed:", message);
  };
  console.error = function() {
    // Do nothing or log the message to console
    console.log("Error suppressed:", arguments);
};

// Override console.warn to suppress warning messages
console.warn = function() {
    // Do nothing or log the message to console
    console.log("Warning suppressed:", arguments);
};
    let toShiny;
    let checkBoxs=[];
    document.getElementById('profilePlot').innerHTML = "<p style = 'font-size:20px'> Retrieving database menu <p> <br> <div class='loader-profile'></div>"
    const firebaseConfig = {
      apiKey: "AIzaSyDZopCl6jqND4sFYCSiB1GpCXreXd6-Q9s",
      authDomain: "speaker-calibration.firebaseapp.com",
      databaseURL: "https://speaker-calibration-default-rtdb.firebaseio.com",
      projectId: "speaker-calibration",
      storageBucket: "speaker-calibration.appspot.com",
      messagingSenderId: "322038930574",
      appId: "1:322038930574:web:d10ca9e7d60b6da9bafddf",
      measurementId: "G-3724GD92R6",
    };
    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    function addToMap(map, value) {
      if (value) {
        const lowercaseValue = value.toLowerCase();
      if (!map.has(lowercaseValue)) {
        map.set(lowercaseValue, new Set());
      }
      map.get(lowercaseValue).add(value);
      } else {
        return;
      }
    }

    var micOEMs = new Set();
    var micModelNames = new Set();
    var micIDs = new Set();
    var mic51IDs = new Set();

    var micOEMsMap = new Map();
    var micModelNamesMap = new Map();
    var micIDsMap = new Map();
    
    var mics = db.collection("Microphones");
    var loudspeakers = db.collection("Loudspeakers");
    await mics.get().then((querySnapshot) => {
      querySnapshot.forEach((doc) => {
        addToMap(micOEMsMap, doc.data().OEM);
        addToMap(micModelNamesMap, doc.data().micModelName);
        addToMap(micIDsMap, doc.data().ID);
        mic51IDs.add(doc.data().ID_from_51Degrees);
      });
    });
    micOEMsMap.forEach((values, lowercaseOEM) => {
      const [firstCaseOEM] = values;
      if (firstCaseOEM) {
        micOEMs.add(firstCaseOEM);
      }
    });
    micModelNamesMap.forEach((values, micModelName) => {
      const [firstCaseMicModelName] = values;
      if (firstCaseMicModelName) {
        micModelNames.add(firstCaseMicModelName);
      }
    });
    micIDsMap.forEach((values, lowercaseID) => {
      const [firstCaseID] = values;
      if (firstCaseID) {
        micIDs.add(firstCaseID);
      }
    });


    var speakerOEMs = new Set();
    var speakerModelNames = new Set();
    var speakerIDs = new Set();
    var speaker51IDs = new Set();

    var speakerOEMsMap = new Map();
    var speakerModelNamesMap = new Map();
    var speakerIDsMap = new Map();

    await loudspeakers
    .get()
    .then((querySnapshot) => {
      querySnapshot.forEach((doc) => {
        addToMap(speakerOEMsMap, doc.data().OEM);
        addToMap(speakerModelNamesMap, doc.data().fullLoudspeakerModelName);
        addToMap(speakerIDsMap, doc.data().fullLoudspeakerModelNumber);
        speaker51IDs.add(doc.data().DeviceId);
        })
      });
    
      speakerOEMsMap.forEach((values, lowercaseOEM) => {
        const [firstCaseOEM] = values;
        if (firstCaseOEM) {
          speakerOEMs.add(firstCaseOEM);
        }
      });
      speakerModelNamesMap.forEach((values, speakerModelName) => {
        const [firstCaseMicModelName] = values;
        if (firstCaseMicModelName) {
          speakerModelNames.add(firstCaseMicModelName);
        }
      });
      speakerIDsMap.forEach((values, lowercaseID) => {
        const [firstCaseID] = values;
        if (firstCaseID) {
          speakerIDs.add(firstCaseID);
        }
      });

     console.log(speakerIDs);

    const SDToleranceContainer = document.getElementById("SDTolerance");
    const filterBoolContainer = document.getElementById("filterBool");
    const DeviceIDContainer = document.getElementById("deviceID");
    
    filterBoolContainer.checked = false;
    SDToleranceContainer.value = 10.0;
    const transducerSelect = document.getElementById("transducer");
    transducerSelect.innerHTML = "";
    let microphoneOption = document.createElement("option");
    microphoneOption.value = "Microphones";
    microphoneOption.text = "Microphones";
    transducerSelect.add(microphoneOption);
    let loudspeakerOption = document.createElement("option");
    loudspeakerOption.value = "Loudspeakers";
    loudspeakerOption.text = "Loudspeakers";
    transducerSelect.add(loudspeakerOption);

    const OEMSelect = document.getElementById("OEM");
    const modelsContainer = document.getElementById("Model");
    const IDcontainers = document.getElementById("IDs");
    
    function updateOEMsContainer() {
      OEMSelect.innerHTML = "";
      let OEMelement = document.createElement("option");
      OEMelement.value = "All";
      OEMelement.text = "All";
      OEMSelect.add(OEMelement);
     
      if (transducerSelect.value == "Microphones") {
        micOEMs.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        OEMSelect.add(optionElement);
      });
      } else {
        speakerOEMs.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        OEMSelect.add(optionElement);
      });
      }
    }

    function updateModelsContainer() {
      modelsContainer.innerHTML = "";
      let modelElement = document.createElement("option");
      modelElement.value = "All";
      modelElement.text = "All";
      modelsContainer.add(modelElement);
      if (transducerSelect.value == "Microphones") {
        micModelNames.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        modelsContainer.add(optionElement);
      });
      } else {
        speakerModelNames.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        modelsContainer.add(optionElement);
      });
      }
      
    }
    
    function updateIDContainer() {
      IDcontainers.innerHTML = "";
      let IDElement = document.createElement("option");
      IDElement.value = "All";
      IDElement.text = "All";
      IDcontainers.add(IDElement);
      if (transducerSelect.value == "Microphones") {
        micIDs.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        IDcontainers.add(optionElement);
      });
      } else {
        speakerIDs.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        IDcontainers.add(optionElement);
      });
      }
    }
    
    function updateDeviceIDContainer() {
      DeviceIDContainer.innerHTML = "";
      let deviceIDelement = document.createElement("option");
      deviceIDelement.value = "All";
      deviceIDelement.text = "All";
      DeviceIDContainer.add(deviceIDelement);
     
      if (transducerSelect.value == "Microphones") {
        mic51IDs.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        DeviceIDContainer.add(optionElement);
      });
      } else {
        speaker51IDs.forEach((option) => {
        const optionElement = document.createElement("option");
        optionElement.value = option;
        optionElement.text = option;
        DeviceIDContainer.add(optionElement);
      });
      }
    }

    updateOEMsContainer();
    updateModelsContainer();
    updateIDContainer();
    updateDeviceIDContainer();

    function sanitizeForId(input) {
    // Replace non-alphanumeric characters with underscores
    return String(input).replace(/[^a-zA-Z0-9-]/g, '-');
  }

    async function updatePlot(whatToPlot) {
      // const selectedModels = Array.from(modelsContainer.querySelectorAll('input[type="checkbox"]:checked')).map((checkbox) => checkbox.value);

      document.getElementById("profilePlot").innerHTML = "<div class='loader-profile'></div>";
      const data = [];
      let i = 0;
      let query, selectedValue;
      let OEMquery, modelQuery, IDQuery;
      if (transducerSelect.value == "Microphones") {
        OEMquery = OEMSelect.value == "All" ?
        mics :
          mics.where("OEM", "in", [...micOEMsMap.get(OEMSelect.value.toLowerCase())] || []);
        modelQuery = modelsContainer.value == "All" ?
        OEMquery :
          mics.where("micModelName", "in", [...micModelNamesMap.get(modelsContainer.value.toLowerCase())]);
        IDQuery = IDcontainers.value == "All" ?
        modelQuery : 
        mics.where("ID", "in", [...micIDsMap.get(IDcontainers.value.toLowerCase())]);
      } else {
        console.log("isLoudspeaker");
        OEMquery = OEMSelect.value == "All" ?
          loudspeakers :
          loudspeakers.where(
                "OEM",
                "in",
                  [...speakerOEMsMap.get(OEMSelect.value.toLowerCase())] || []);
        modelQuery = modelsContainer.value == "All" ?
          OEMquery :
          loudspeakers
            .where(
              "fullLoudspeakerModelName",
              "in",
              [...speakerModelNamesMap.get(modelsContainer.value.toLowerCase())] || []);
          IDQuery = IDcontainers.value == "All" ?
          modelQuery : 
          loudspeakers
            .where("fullLoudspeakerModelNumber", "in", 
            [...speakerIDsMap.get(IDcontainers.value.toLowerCase())] || []);
      }

      if (whatToPlot === "micOEM") {
        selectedValue = OEMSelect.value; 
        query = OEMquery;
      } else if (whatToPlot === "micModelName") {
        selectedValue = modelsContainer.value == "All" ? OEMSelect.value : modelsContainer.value;
        query = modelQuery;
      } else if (whatToPlot === "micID" || whatToPlot === "speakerID") {
        selectedValue = IDcontainers.value == "All" ? modelsContainer.value : IDcontainers.value;
        query = IDQuery;
      } else if (whatToPlot === "speakerOEM") {
        selectedValue = OEMSelect.value; 
        query = OEMquery;
      } else if (whatToPlot === "speakerModelName") {
        selectedValue = modelsContainer.value == "All" ? OEMSelect.value : modelsContainer.value;
        query = modelQuery;
      } else if (whatToPlot === "mic51ID") {
        console.log("mic51ID");
        query = mics.where("ID_from_51Degrees", "==", DeviceIDContainer.value);
        console.log(query);
      } else {
        selectedValue = DeviceIDContainer.value;
        query = loudspeakers.where("DeviceId", "==", DeviceIDContainer.value);
      }

      try {
        toShiny = {
          createDates:[],
          jsonFileName:[],
          OEMs:[],
          modelNames:[],
          modelNumbers:[],
          SDs:[],
          FilteredMLSRange:[],
          labels:[],
          title:[],
          isDefault:[],
        };
        checkBoxs = {
          id:[],
          fileName:[]
        };
        let j = 1;
        await query.get().then((querySnapshot) => {
          querySnapshot.forEach((doc) => {
          // let docData;
          // if (transducerSelect.value == "Microphones") {
          //   docData = doc.data().linear.Freq.map((x, i) => ({ x: x, y: doc.data().linear.Gain[i] }));
          // } else {
          //   docData = doc.data().ir.Freq.map((x, i) => ({ x: x, y: doc.data().ir.Gain[i] }));
          // }
          let label;
          
          if (whatToPlot === "micOEM") {
            // micModelNames.add(doc.data().micModelName);
            // micIDs.add(doc.data().ID);
            label = `${doc.data().micModelName}/${doc.data().isDefault ? "default" : doc.data().DateText}`;
          } else if (whatToPlot === "micModelName") {
            // micIDs.add(doc.data().ID);
            label = `${doc.data().ID}/${doc.data().isDefault ? "default" : doc.data().DateText}`;
          } else if (whatToPlot === "micID") {
            label = doc.data().isDefault ? "default" : doc.data().DateText;
            // speakers
          } else if (whatToPlot === "speakerOEM") {
            // speakerModelNames.add(doc.data().fullLoudspeakerModelName);
            // speakerIDs.add(doc.data().fullLoudspeakerModelNumber);
            label = `${doc.data().fullLoudspeakerModelName}/${doc.data().CalibrationDate}`;
          } else if (whatToPlot === "speakerModelName") {
            // speakerIDs.add(doc.data().fullLoudspeakerModelNumber);
            label = `${doc.data().fullLoudspeakerModelNumber}/${doc.data().CalibrationDate}`;
          } else{
            label = doc.data().CalibrationDate;
          } 

          if (
            (!filterBoolContainer.checked ||
            doc.data().isDefault ||
             doc.data().componentCorrectionSD <= SDToleranceContainer.value) &&
             (doc.data().ir || doc.data().linear)) 
             {
              console.log(doc.data().ir)
              console.log(doc.data().componentCorrectionSD);
              // sent to shiny server to create datatable
              toShiny.createDates.push(transducerSelect.value == "Microphones" ? doc.data().DateText: doc.data().CalibrationDate);
              toShiny.jsonFileName.push(doc.data().jsonFileName);
              checkBoxs.id.push(sanitizeForId(doc.data().jsonFileName));
              checkBoxs.fileName.push(doc.data().jsonFileName);
              toShiny.OEMs.push(doc.data().OEM);
              toShiny.modelNames.push(
                transducerSelect.value == "Microphones" ? 
                doc.data().micModelName :
                doc.data().fullLoudspeakerModelName);
              toShiny.modelNumbers.push(
                transducerSelect.value == "Microphones" ? 
                doc.data().ID :
                doc.data().fullLoudspeakerModelNumber
                );
              toShiny.SDs.push(doc.data().componentCorrectionSD);
              toShiny.FilteredMLSRange.push(doc.data().filteredMLSComponentMax);
              toShiny.labels.push(label);
              toShiny.isDefault.push(doc.data().isDefault);
              data.push(doc.data());
            //   data.push({
            //   label: label,
            //   data: docData,
            //   backgroundColor: "rgba(0, 0, 0, 0)",
            //   pointRadius: 0,
            //   borderColor: getRandomColor(i),
            //   borderDash: getBorderDash(i++),
            //   showLine: true,
            //   borderWidth: 2,
            // });
            console.log("end processing", new Date());
          }
        });

        console.log(toShiny);
        Shiny.setInputValue("transducerType", transducerSelect.value);
        Shiny.setInputValue("plotTitle", "Profiles for " + selectedValue);
        Shiny.setInputValue("toShiny", JSON.stringify(toShiny));
        Shiny.setInputValue("totalData", JSON.stringify(data));

        // document.getElementById("profilePlot").innerHTML = "";
        // if (whatToPlot === "micModelName") {
        //   updateIDContainer();
        // } else if (whatToPlot === "micOEM") {
        //   updateModelsContainer();
        //   updateIDContainer();
        // }
        // createChart(selectedValue, data, false);
        
  

    //     const dataTable = $('#dataTable').DataTable({
    //       "rowCallback": function(row, data) {
    //         // Row callback function
    //         for (var i = 0; i < data.length; i++) {
    //             if (data[i] === null || data[i] == undefined) {
    //                 $('td:eq(' + i + ')', row).html('NA')
    //                     .css({ 'color': 'rgb(151,151,151)', 'font-style': 'italic' });
    //             }
    //         }
    //     },
    //     suppressWarnings: true,
    //         data: toShiny.createDates.map((date, index) => [
    //             date,
    //             toShiny.jsonFileName[index],
    //             toShiny.OEMs[index],
    //             toShiny.modelNames[index],
    //             toShiny.modelNumbers[index],
    //             toShiny.SDs[index],
    //             toShiny.FilteredMLSRange[index],
    //             toShiny.labels[index],
    //             toShiny.isDefault[index],
    //             // `<input type="checkbox" id = "${sanitizeForId(toShiny.jsonFileName[index])}" class="row-checkbox" />`
    //         ]),
    //         paging: false,
    //         stripeClasses: [],
    //         order: [[8, 'desc']],
    //         columns: [
    //             { title: 'Date' },
    //             { title: 'JSON File Name' },
    //             { title: 'OEM' },
    //             { title: 'Model Name' },
    //             { title: 'Model Number' },
    //             { title: 'SD' },
    //             { title: 'Filtered MLS Range' },
    //             { title: 'Label' },
    //             { title: 'Is Default' },
    //             // { title: 'Select', orderable: false }
    //         ],
    //       });
    //   });
    //   toShiny.jsonFileName.forEach((value) => {
    // const sanitizedId = sanitizeForId(value);
    // console.log(sanitizedId);
});
      } catch (error) {
        console.error("Error updating plot:", error);
      }
    }


    function refreshShinyPlot() {
      const dataTableElement = $('#dataTable');

    // Get the data of the selected rows
    const selectedRowsData = $(dataTableElement).DataTable().rows('.selected').data().toArray();
    console.log($(dataTableElement));
    // Extract jsonFileName values from the selected rows
    const jsonFileNames = selectedRowsData.map(row => row[1]); // Assuming jsonFileName is at index 1

    // Perform actions based on the jsonFileNames
    console.log('Selected jsonFileNames:', jsonFileNames);
    };


    // event listeners
    transducerSelect.addEventListener("change", () => {
      updateOEMsContainer();
      updateModelsContainer();
      updateIDContainer();
      updateDeviceIDContainer();
      if (transducerSelect.value == "Microphones") {
        // updatePlot("micOEM");
      } else {
        // updatePlot("speakerOEM");
      }
    });


    // modelsContainer.addEventListener("change", updatePlot);
    document.getElementById('refreshButton').onclick = async() => {
      if (transducerSelect.value == "Microphones") {
        if (DeviceIDContainer.value != "All") {
          await updatePlot("mic51ID");
        } else if (IDcontainers.value != "All") {
          await updatePlot("micID");
        } else if (modelsContainer.value != "All") {
          await updatePlot("micModel");
        } else {
          await updatePlot("micOEM");
        }
      } else {
        if (DeviceIDContainer.value != "All") {
          await updatePlot("speaker51ID");
        } else if (IDcontainers.value != "All") {
          await updatePlot("speakerID");
        } else if (modelsContainer.value != "All") {
          await updatePlot("speakerModel");
        } else {
          await updatePlot("speakerOEM");
        }
      }
    }
    // document.getElementById("updatePlot").onclick = () => {
    //   refreshShinyPlot();
    // }
    // updateModelCheckboxes();
    // updatePlot();
    document.getElementById('profilePlot').innerHTML = "<p style = 'font-size:20px'> Hit refresh or use selector to retrieve profiles <p>"

  </script>


</body>

</html>